import io\nimport os\nimport docker\nimport tarfile\nfrom typing import List, Optional, Union\nfrom docker.models.images import Image\nfrom docker.models.containers import Container\nfrom llm_sandbox.utils import (\n    image_exists,\n    get_libraries_installation_command,\n    get_code_file_extension,\n    get_code_execution_command,\n)\nfrom llm_sandbox.const import SupportedLanguage, SupportedLanguageValues, DefaultImage, NotSupportedLibraryInstallation\n\nclass SandboxSession:\n    def __init__(\n        self,\n        image: Optional[str] = None,\n        dockerfile: Optional[str] = None,\n        lang: str = SupportedLanguage.PYTHON,\n        keep_template: bool = False,\n        verbose: bool = True,\n    ) -> None:\n        """\n        Initialize a new sandbox session.\n\n        :param image: Docker image to use.\n        :param dockerfile: Path to the Dockerfile, if image is not provided.\n        :param lang: Language of the code.\n        :param keep_template: If True, the image and container will not be removed after the session ends.\n        :param verbose: If True, print messages.\n        """\n        if image and dockerfile:\n            raise ValueError("Only one of image or dockerfile should be provided")\n        if lang not in SupportedLanguageValues:\n            raise ValueError(f"Language {lang} is not supported. Must be one of {SupportedLanguageValues}")\n        if not image and not dockerfile:\n            image = DefaultImage.__dict__[lang.upper()]\n\n        self.lang = lang\n        self.client = docker.from_env()\n        self.image = image\n        self.dockerfile = dockerfile\n        self.container = None\n        self.path = None\n        self.keep_template = keep_template\n        self.is_create_template = False\n        self.verbose = verbose\n\n    def open(self) -> None:\n        if self.dockerfile:\n            self.path = os.path.dirname(self.dockerfile)\n            if self.verbose:\n                print(f"Building docker image from {self.dockerfile}")\n                if self.keep_template:\n                    print("Warning: Since the `keep_template` flag is set to True, the docker image will not be removed after the session ends and remains for future use.")\n            self.image, _ = self.client.images.build(\n                path=self.path,\n                dockerfile=os.path.basename(self.dockerfile),\n                tag="sandbox",\n            )\n            self.is_create_template = True\n        elif isinstance(self.image, str):\n            if not image_exists(self.client, self.image):\n                if self.verbose:\n                    print(f"Pulling image {self.image}..")\n                    if self.keep_template:\n                        print("Warning: Since the `keep_template` flag is set to True, the docker image will not be removed after the session ends and remains for future use.")\n                self.image = self.client.images.pull(self.image)\n                self.is_create_template = True\n            else:\n                self.image = self.client.images.get(self.image)\n                if self.verbose:\n                    print(f"Using image {self.image.tags[-1]}")\n        self.container = self.client.containers.run(self.image, detach=True, tty=True)\n\n    def close(self) -> None:\n        if self.container:\n            if isinstance(self.image, Image):\n                self.container.commit(self.image.tags[-1])\n            self.container.remove(force=True)\n            self.container = None\n        if self.is_create_template and not self.keep_template:\n            containers = self.client.containers.list(all=True)\n            image_id = self.image.id if isinstance(self.image, Image) else self.client.images.get(self.image).id\n            image_in_use = any(container.image.id == image_id for container in containers)\n            if not image_in_use:\n                if isinstance(self.image, str):\n                    self.client.images.remove(self.image)\n                elif isinstance(self.image, Image):\n                    self.image.remove(force=True)\n                else:\n                    raise ValueError("Invalid image type")\n            elif self.verbose:\n                print(f"Image {self.image.tags[-1]} is in use by other containers. Skipping removal..")\n\n    def run(self, code: str, libraries: Optional[List[str]] = None) -> List[str]:\n        if not self.container:\n            raise RuntimeError("Session is not open. Please call open() method before running code.")\n        commands = []\n        if libraries:\n            if self.lang.upper() in NotSupportedLibraryInstallation:\n                raise ValueError(f"Library installation has not been supported for {self.lang} yet!")\n            command = get_libraries_installation_command(self.lang, libraries)\n            commands.append(command)\n        code_file = f"/tmp/code.{get_code_file_extension(self.lang)}"\n        with open(code_file, "w") as f:\n            f.write(code)\n        self.copy_to_runtime(code_file, code_file)\n        commands.append(get_code_execution_command(self.lang, code_file))\n        results = []\n        for command in commands:\n            result = self.execute_command(command)\n            results.append(result)\n        return results\n\n    def copy_from_runtime(self, src: str, dest: str) -> None:\n        if not self.container:\n            raise RuntimeError("Session is not open. Please call open() method before copying files.")\n        if self.verbose:\n            print(f"Copying {self.container.short_id}:{src} to {dest}..")\n        bits, stat = self.container.get_archive(src)\n        if stat["size"] == 0:\n            raise FileNotFoundError(f"File {src} not found in the container")\n        tarstream = io.BytesIO(b"".join(bits))\n        with tarfile.open(fileobj=tarstream, mode="r") as tar:\n            tar.extractall(os.path.dirname(dest))\n\n    def copy_to_runtime(self, src: str, dest: str) -> None:\n        if not self.container:\n            raise RuntimeError("Session is not open. Please call open() method before copying files.")\n        directory = os.path.dirname(dest)\n        if directory and not os.path.exists(directory):\n            self.container.exec_run(f"mkdir -p {directory}")\n            if self.verbose:\n                print(f"Creating directory {self.container.short_id}:{directory}")\n        if self.verbose:\n            print(f"Copying {src} to {self.container.short_id}:{dest}..")\n        tarstream = io.BytesIO()\n        with tarfile.open(fileobj=tarstream, mode="w") as tar:\n            tar.add(src, arcname=os.path.basename(src))\n        tarstream.seek(0)\n        self.container.put_archive(os.path.dirname(dest), tarstream)\n\n    def execute_command(self, command: Optional[str]) -> str:\n        if command is None or command.strip() == "":\n            raise ValueError("Command cannot be empty")\n        if not self.container:\n            raise RuntimeError("Session is not open. Please call open() method before executing commands.")\n        if self.verbose:\n            print(f"Executing command: {command}")\n        _, exec_log = self.container.exec_run(command, stream=True)\n        output = ""\n        for chunk in exec_log:\n            chunk_str = chunk.decode("utf-8")\n            output += chunk_str\n            if self.verbose:\n                print(chunk_str, end="")\n        return output\n\n    def __enter__(self) -> 'SandboxSession':\n        self.open()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -> None:\n        self.close()\n