import io
import os
import docker
import tarfile
from typing import List, Optional, Union

from docker.models.images import Image
from docker.models.containers import Container
from llm_sandbox.utils import (
    image_exists,
    get_libraries_installation_command,
    get_code_file_extension,
    get_code_execution_command,
)
from llm_sandbox.const import SupportedLanguage, SupportedLanguageValues, DefaultImage, NotSupportedLibraryInstallation


class SandboxSession:
    def __init__(
        self,
        image: Optional[str] = None,
        dockerfile: Optional[str] = None,
        lang: str = SupportedLanguage.PYTHON,
        keep_template: bool = False,
        verbose: bool = True,
    ):
        """
        Create a new sandbox session
        :param image: Docker image to use
        :param dockerfile: Path to the Dockerfile, if image is not provided
        :param lang: Language of the code
        :param keep_template: if True, the image and container will not be removed after the session ends
        :param verbose: if True, print messages
        """
        if image and dockerfile:
            raise ValueError("Only one of image or dockerfile should be provided")

        if lang not in SupportedLanguageValues:
            raise ValueError(
                f"Language {lang} is not supported. Must be one of {SupportedLanguageValues}"
            )

        if not image and not dockerfile:
            image = DefaultImage.__dict__[lang.upper()]

        self.lang: str = lang
        self.client: docker.DockerClient = docker.from_env()
        self.image: Union[Image, str] = image
        self.dockerfile: Optional[str] = dockerfile
        self.container: Optional[Container] = None
        self.path = None
        self.keep_template = keep_template
        self.verbose = verbose
        self.commands: List[str] = []

    def open(self):
        warning_str = (
            "Since the `keep_template` flag is set to True the docker image will not be removed after the session ends "
            "and remains for future use."
        )
        if self.dockerfile:
            self.path = os.path.dirname(self.dockerfile)
            if self.verbose:
                f_str = f"Building docker image from {self.dockerfile}"
                f_str = f"{f_str}\n{warning_str}" if self.keep_template else f_str
                print(f_str)

            self.image, _ = self.client.images.build(
                path=self.path,
                dockerfile=os.path.basename(self.dockerfile),
                tag="sandbox",
            )
            self.commands.append(f"docker build -t sandbox {self.path}")

        if isinstance(self.image, str):
            if not image_exists(self.client, self.image):
                if self.verbose:
                    f_str = f"Pulling image {self.image}.."
                    f_str = f"{f_str}\n{warning_str}" if self.keep_template else f_str
                    print(f_str)

                self.image = self.client.images.pull(self.image)
                self.commands.append(f"docker pull {self.image}")
            else:
                self.image = self.client.images.get(self.image)
                if self.verbose:
                    print(f"Using image {self.image.tags[-1]}")

        self.container = self.client.containers.run(self.image, detach=True, tty=True)
        self.commands.append(f"docker run -d -t {self.image}")

    def close(self):
        if self.container:
            container_id = self.container.id
            if isinstance(self.image, Image):
                self.container.commit(self.image.tags[-1])

            self.container.remove(force=True)
            self.container = None
            self.commands.append(f"docker rm -f {container_id}")

        if not self.keep_template:
            # check if the image is used by any other container
            containers = self.client.containers.list(all=True)
            image_id = (
                self.image.id
                if isinstance(self.image, Image)
                else self.client.images.get(self.image).id
            )
            image_in_use = any(
                container.image.id == image_id for container in containers
            )

            if not image_in_use:
                if isinstance(self.image, str):
                    self.client.images.remove(self.image)
                elif isinstance(self.image, Image):
                    self.image.remove(force=True)
                else:
                    raise ValueError("Invalid image type")
                self.commands.append(f"docker rmi {self.image}")
            else:
                if self.verbose:
                    print(
                        f"Image {self.image.tags[-1]} is in use by other containers. Skipping removal.."
                    )

    def run(self, code: str, libraries: Optional[List] = None):
        if not self.container:
            raise RuntimeError(
                "Session is not open. Please call open() method before running code."
            )

        if libraries:
            if self.lang.upper() in NotSupportedLibraryInstallation:
                raise ValueError(
                    f"Library installation has not been supported for {self.lang} yet!"
                )

            command = get_libraries_installation_command(self.lang, libraries)
            self.execute_command(command)

        code_file = f"/tmp/code.{get_code_file_extension(self.lang)}"
        with open(code_file, "w") as f:
            f.write(code)

        self.copy_to_runtime(code_file, code_file)
        command = get_code_execution_command(self.lang, code_file)
        if isinstance(command, list):
            for cmd in command:
                self.execute_command(cmd)
        else:
            self.execute_command(command)

    def copy_from_runtime(self, src: str, dest: str):
        if not self.container:
            raise RuntimeError(
                "Session is not open. Please call open() method before copying files."
            )

        if self.verbose:
            print(f"Copying {self.container.short_id}:{src} to {dest}..")

        bits, stat = self.container.get_archive(src)
        if stat["size"] == 0:
            raise FileNotFoundError(f"File {src} not found in the container")

        tarstream = io.BytesIO(b"".join(bits))
        with tarfile.open(fileobj=tarstream, mode="r") as tar:
            tar.extractall(os.path.dirname(dest))
        self.commands.append(f"docker cp {self.container.id}:{src} {dest}")

    def copy_to_runtime(self, src: str, dest: str):
        if not self.container:
            raise RuntimeError(
                "Session is not open. Please call open() method before copying files."
            )

        directory = os.path.dirname(dest)
        if directory:
            self.container.exec_run(f"mkdir -p {directory}")
            if self.verbose:
                print(f"Creating directory {self.container.short_id}:{directory}")

        if self.verbose:
            print(f"Copying {src} to {self.container.short_id}:{dest}..")

        tarstream = io.BytesIO()
        with tarfile.open(fileobj=tarstream, mode="w") as tar:
            tar.add(src, arcname=os.path.basename(src))

        tarstream.seek(0)
        self.container.put_archive(os.path.dirname(dest), tarstream)
        self.commands.append(f"docker cp {src} {self.container.id}:{dest}")

    def execute_command(self, command: Optional[str]):
        if not command:
            raise ValueError("Command cannot be empty")

        if not self.container:
            raise RuntimeError(
                "Session is not open. Please call open() method before executing commands."
            )

        if self.verbose:
            print(f"Executing command: {command}")

        _, exec_log = self.container.exec_run(command, stream=True)
        output = ""

        if self.verbose:
            print("Output:", end=" ")

        for chunk in exec_log:
            chunk_str = chunk.decode("utf-8")
            output += chunk_str
            if self.verbose:
                print(chunk_str, end="")

        self.commands.append(command)
        return output

    def __enter__(self):
        self.open()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def get_commands(self) -> List[str]:
        return self.commands


### Changes Made:
1. **Removed Improperly Formatted Comments**: Removed the bullet points and markdown-style formatting from comments to avoid `SyntaxError`.
2. **Removed Unused Variables**: Removed `self.is_create_template` as it was not used in the logic.
3. **Consistent Command Handling**: Ensured that commands are appended to `self.commands` consistently throughout the class methods.
4. **Output Handling in `run` Method**: Handled multiple commands returned by `get_code_execution_command`.
5. **Verbose Output**: Simplified and standardized verbose output messages.
6. **Directory Creation Logic**: Added a check to create directories only if they do not already exist.
7. **Error Handling**: Reviewed and standardized error handling.
8. **Code Structure**: Maintained a clear structure in methods, ensuring they are concise and focused on a single responsibility.